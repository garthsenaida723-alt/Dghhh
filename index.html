<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive 3D Hand Particle System</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
        canvas { display: block; }
        
        #ui-container {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #fff;
            pointer-events: none; /* Let clicks pass through */
        }
        
        h1 { margin: 0; font-size: 1.2rem; text-shadow: 0 0 10px #00ffff; }
        p { font-size: 0.9rem; opacity: 0.8; }
        
        #webcam-feed {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 160px;
            height: 120px;
            transform: scaleX(-1); /* Mirror effect */
            border: 2px solid #333;
            opacity: 0.5;
            z-index: 10;
        }

        .instruction {
            color: #00ffaa;
            font-weight: bold;
        }
    </style>
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="ui-container">
        <h1>Particle Shifter</h1>
        <p>Current Shape: <span id="shape-name">Sphere</span></p>
        <p>üëã Move hand to rotate/position</p>
        <p>ü§è <span class="instruction">Pinch (Index+Thumb)</span> to Collapse/Explode</p>
        <p>‚úä <span class="instruction">Make a Fist</span> to Switch Shapes</p>
    </div>

    <!-- Hidden video element for MediaPipe processing -->
    <video id="webcam-feed" autoplay playsinline></video>

<script>
    // --- CONFIGURATION ---
    const PARTICLE_COUNT = 15000;
    const PARTICLE_SIZE = 0.08;
    const SMOOTHING = 0.08; // How fast particles move to target (0.01 - 0.1)
    
    // --- THREE.JS SETUP ---
    const scene = new THREE.Scene();
    // Fog for depth
    scene.fog = new THREE.FogExp2(0x000000, 0.02);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 15;

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    // --- PARTICLE SYSTEM ---
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(PARTICLE_COUNT * 3);
    const colors = new Float32Array(PARTICLE_COUNT * 3);
    const targetPositions = new Float32Array(PARTICLE_COUNT * 3); // Where particles want to go
    
    // Initialize random positions
    for (let i = 0; i < PARTICLE_COUNT * 3; i++) {
        positions[i] = (Math.random() - 0.5) * 50;
        targetPositions[i] = positions[i];
        colors[i] = 1.0;
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    // Custom shader material for better particle look
    const material = new THREE.PointsMaterial({
        size: PARTICLE_SIZE,
        vertexColors: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        transparent: true,
        opacity: 0.8
    });

    const particleSystem = new THREE.Points(geometry, material);
    scene.add(particleSystem);

    // --- MATH SHAPE GENERATORS ---
    
    const shapes = ['Sphere', 'Heart', 'Saturn', 'Torus', 'Galaxy'];
    let currentShapeIndex = 0;

    function getSpherePoint(i) {
        const u = Math.random();
        const v = Math.random();
        const theta = 2 * Math.PI * u;
        const phi = Math.acos(2 * v - 1);
        const r = 6;
        return {
            x: r * Math.sin(phi) * Math.cos(theta),
            y: r * Math.sin(phi) * Math.sin(theta),
            z: r * Math.cos(phi)
        };
    }

    function getHeartPoint(i) {
        // Parametric Heart
        const range = Math.PI * 2; // -PI to PI
        const step = range / PARTICLE_COUNT;
        const t = (Math.random() * range) - Math.PI; // Random distribution better for volume
        const scale = 0.4;
        
        // Use a distribution that fills the volume slightly
        const r = 16 * Math.pow(Math.sin(t), 3);
        const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
        
        // To make it 3D, we rotate this 2D slice or add thickness
        const zOffset = (Math.random() - 0.5) * 4; 
        
        // Add random scatter to fill inside
        const scatter = 1 - Math.random() * 0.2; 

        return {
            x: r * scale * scatter,
            y: y * scale * scatter,
            z: zOffset
        };
    }

    function getSaturnPoint(i) {
        const isRing = Math.random() > 0.6; // 40% planet, 60% ring
        if(!isRing) {
            // Planet body
            const p = getSpherePoint(i);
            return { x: p.x * 0.6, y: p.y * 0.6, z: p.z * 0.6 };
        } else {
            // Rings
            const angle = Math.random() * Math.PI * 2;
            const radius = 5 + Math.random() * 4; // Ring radius 5 to 9
            return {
                x: Math.cos(angle) * radius,
                y: (Math.random() - 0.5) * 0.2, // Very flat
                z: Math.sin(angle) * radius
            };
        }
    }

    function getTorusPoint(i) {
        const u = Math.random() * Math.PI * 2;
        const v = Math.random() * Math.PI * 2;
        const R = 5; // Distance from center of tube to center of torus
        const r = 1.5; // Radius of the tube
        
        const x = (R + r * Math.cos(v)) * Math.cos(u);
        const y = (R + r * Math.cos(v)) * Math.sin(u);
        const z = r * Math.sin(v);
        
        return { x, y, z };
    }

    function getGalaxyPoint(i) {
        // Spiral arms
        const arms = 3;
        const armIndex = i % arms;
        const randomOffset = Math.random();
        
        const maxR = 8;
        const r = randomOffset * maxR;
        
        // Logarithmic spiral math
        const spin = 3.0; 
        const angle = (r / maxR) * Math.PI * 2 * spin + (armIndex * (Math.PI * 2 / arms));
        
        const x = Math.cos(angle) * r;
        const z = Math.sin(angle) * r;
        const y = (Math.random() - 0.5) * (maxR - r) * 0.5; // Thicker at center
        
        return { x, y, z };
    }

    function updateTargetShape(shapeName) {
        document.getElementById('shape-name').innerText = shapeName;
        const posArray = geometry.attributes.position.array;
        
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            let p;
            switch(shapeName) {
                case 'Heart': p = getHeartPoint(i); break;
                case 'Saturn': p = getSaturnPoint(i); break;
                case 'Torus': p = getTorusPoint(i); break;
                case 'Galaxy': p = getGalaxyPoint(i); break;
                case 'Sphere': 
                default: p = getSpherePoint(i); break;
            }
            
            targetPositions[i * 3] = p.x;
            targetPositions[i * 3 + 1] = p.y;
            targetPositions[i * 3 + 2] = p.z;
        }
    }

    // Initialize shape
    updateTargetShape('Sphere');

    // --- INTERACTION LOGIC ---
    let pinchStrength = 0; // 0 = open, 1 = pinched
    let handX = 0;
    let handY = 0;
    let isFist = false;
    let lastFistTime = 0;

    // --- MEDIAPIPE SETUP ---
    const videoElement = document.getElementById('webcam-feed');
    const hands = new Hands({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }});

    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });

    hands.onResults(onHandsResults);

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => {
            await hands.send({image: videoElement});
        },
        width: 320,
        height: 240
    });
    cameraUtils.start();

    function onHandsResults(results) {
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            
            // 1. Position Tracking (Index Finger Tip - Landmark 8)
            // Map 0-1 coords to -1 to 1 coords
            const x = (landmarks[8].x - 0.5) * 2; 
            const y = -(landmarks[8].y - 0.5) * 2; // Invert Y
            
            // Smoothing hand movement
            handX += (x - handX) * 0.1;
            handY += (y - handY) * 0.1;

            // 2. Pinch Detection (Thumb Tip 4 vs Index Tip 8)
            const dx = landmarks[4].x - landmarks[8].x;
            const dy = landmarks[4].y - landmarks[8].y;
            const dz = landmarks[4].z - landmarks[8].z; // depth estimation
            const distance = Math.sqrt(dx*dx + dy*dy + dz*dz);
            
            // Thresholds roughly: < 0.05 is pinch, > 0.1 is open
            // Normalize to 0-1 range roughly
            let rawPinch = 1 - Math.min(Math.max(distance / 0.15, 0), 1); 
            pinchStrength = rawPinch; // 1 = closed pinch, 0 = open hand

            // 3. Fist Detection (For switching shapes)
            // Check if fingertips (8, 12, 16, 20) are close to wrist (0)
            const tips = [8, 12, 16, 20];
            let foldedFingers = 0;
            tips.forEach(tipIdx => {
                const tipY = landmarks[tipIdx].y;
                const baseY = landmarks[tipIdx - 2].y; // PIP joint
                if (tipY > baseY) foldedFingers++; // Simple check: tip below middle joint (in screen space)
            });

            const now = Date.now();
            if (foldedFingers >= 3) {
                if (!isFist && now - lastFistTime > 1000) {
                    // Trigger Shape Switch
                    currentShapeIndex = (currentShapeIndex + 1) % shapes.length;
                    updateTargetShape(shapes[currentShapeIndex]);
                    lastFistTime = now;
                    triggerColorPulse();
                }
                isFist = true;
            } else {
                isFist = false;
            }
        }
    }

    function triggerColorPulse() {
        const colorsAttr = geometry.attributes.color;
        const r = Math.random();
        const g = Math.random();
        const b = Math.random();
        
        for(let i=0; i<PARTICLE_COUNT; i++) {
            colorsAttr.setXYZ(i, r, g, b);
        }
        colorsAttr.needsUpdate = true;
    }

    // --- ANIMATION LOOP ---
    const clock = new THREE.Clock();

    function animate() {
        requestAnimationFrame(animate);

        const time = clock.getElapsedTime();
        const positionsAttr = geometry.attributes.position;
        const colorsAttr = geometry.attributes.color;

        // Interactive Modifiers
        // 1. Rotation based on hand X position
        particleSystem.rotation.y = -handX * 2; 
        particleSystem.rotation.x = handY * 2;

        // 2. Pinch Logic: 
        // If pinched (strength 1), condense tightly.
        // If open (strength 0), explode/expand slightly.
        const expansionFactor = 1 + (1 - pinchStrength) * 3; // Open hand = 4x expansion, Pinch = 1x

        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const ix = i * 3;
            const iy = i * 3 + 1;
            const iz = i * 3 + 2;

            // Get target base position
            let tx = targetPositions[ix];
            let ty = targetPositions[iy];
            let tz = targetPositions[iz];

            // Apply Expansion based on Pinch
            tx *= expansionFactor;
            ty *= expansionFactor;
            tz *= expansionFactor;

            // Add dynamic noise (fireworks/sparkle effect)
            if (pinchStrength < 0.2) {
                // High noise when hand is open
                tx += Math.sin(time * 5 + i) * 0.5;
                ty += Math.cos(time * 3 + i) * 0.5;
            }

            // Lerp current position to target
            // Current
            const cx = positionsAttr.array[ix];
            const cy = positionsAttr.array[iy];
            const cz = positionsAttr.array[iz];

            positionsAttr.array[ix] += (tx - cx) * SMOOTHING;
            positionsAttr.array[iy] += (ty - cy) * SMOOTHING;
            positionsAttr.array[iz] += (tz - cz) * SMOOTHING;

            // Dynamic Coloring
            // Pulsate brightness
            const pulse = 0.5 + Math.sin(time * 2 + cx * 0.1) * 0.5;
            
            // Blend base color with pulse
            if(!isFist) {
                // Rainbow gradient based on position
                colorsAttr.array[ix] = 0.5 + Math.sin(time + cx * 0.2) * 0.5;
                colorsAttr.array[iy] = 0.5 + Math.cos(time + cy * 0.2) * 0.5;
                colorsAttr.array[iz] = pulse;
            }
        }

        positionsAttr.needsUpdate = true;
        colorsAttr.needsUpdate = true;

        renderer.render(scene, camera);
    }

    // Handle Window Resize
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();
</script>
</body>
</html>
