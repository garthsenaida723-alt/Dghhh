<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Interactive Hand-Tracked 3D Particles</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: sans-serif; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        #video-container {
            position: absolute; bottom: 20px; left: 20px; z-index: 2;
            width: 160px; height: 120px; border-radius: 10px; overflow: hidden;
            border: 2px solid rgba(255, 255, 255, 0.3);
            transform: scaleX(-1); /* Mirror for natural feel */
        }
        video { width: 100%; height: 100%; object-fit: cover; }
        #ui {
            position: absolute; top: 20px; left: 20px; z-index: 3;
            color: white; pointer-events: none;
        }
        h1 { margin: 0; font-size: 1.5rem; text-shadow: 0 0 10px cyan; }
        p { font-size: 0.9rem; opacity: 0.8; }
        .status { color: #00ff88; font-weight: bold; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="ui">
        <h1>Gesture Particles</h1>
        <p>Current Shape: <span id="shape-name" class="status">Loading...</span></p>
        <p>1. Move Hand to guide.<br>2. Pinch to concentrate / Open to explode.</p>
    </div>

    <div id="video-container">
        <video class="input_video"></video>
    </div>
    <div id="canvas-container"></div>

<script>
    // --- Configuration ---
    const PARTICLE_COUNT = 1500;
    const SHAPE_CYCLE_DURATION = 5000; // ms
    
    // --- State ---
    let handPosition = new THREE.Vector3(0, 0, 0);
    let pinchDistance = 0;
    let isHandPresent = false;
    let currentShapeIndex = 0;
    let time = 0;

    // --- Texture Generators (Procedural) ---
    // Instead of loading images, we draw shapes on canvas to create textures
    function createTexture(type) {
        const size = 128;
        const canvas = document.createElement('canvas');
        canvas.width = size;
        canvas.height = size;
        const ctx = canvas.getContext('2d');
        const center = size / 2;

        ctx.clearRect(0, 0, size, size);
        ctx.fillStyle = '#FFFFFF';
        
        if (type === 'firework') {
            // Soft glow dot
            const grad = ctx.createRadialGradient(center, center, 0, center, center, size/2);
            grad.addColorStop(0, 'rgba(255, 255, 255, 1)');
            grad.addColorStop(0.5, 'rgba(255, 255, 255, 0.2)');
            grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,size,size);
        } 
        else if (type === 'heart') {
            // Heart shape
            ctx.beginPath();
            ctx.moveTo(center, center + 30);
            ctx.bezierCurveTo(center + 50, center - 30, center + 50, center - 60, center, center - 40);
            ctx.bezierCurveTo(center - 50, center - 60, center - 50, center - 30, center, center + 30);
            ctx.fill();
        } 
        else if (type === 'flower') {
            // Flower shape
            for (let i = 0; i < 6; i++) {
                ctx.beginPath();
                const angle = (i * Math.PI) / 3;
                const x = center + Math.cos(angle) * 20;
                const y = center + Math.sin(angle) * 20;
                ctx.arc(x, y, 20, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.beginPath();
            ctx.arc(center, center, 10, 0, Math.PI * 2); // Center
            ctx.fill();
        }
        else if (type === 'saturn') {
            // Planet with Ring
            ctx.beginPath();
            ctx.arc(center, center, 15, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(center, center, 35, 10, Math.PI / 6, 0, Math.PI * 2);
            ctx.lineWidth = 4;
            ctx.strokeStyle = 'white';
            ctx.stroke();
        }

        const texture = new THREE.CanvasTexture(canvas);
        return texture;
    }

    // --- Three.js Setup ---
    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x050505, 0.002);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 50;

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    container.appendChild(renderer.domElement);

    // --- Particle System Logic ---
    const shapes = [
        { id: 'firework', name: 'Cosmic Dust', color: 0x00ffff, texture: createTexture('firework') },
        { id: 'heart', name: 'Love Hearts', color: 0xff0055, texture: createTexture('heart') },
        { id: 'flower', name: 'Garden Bloom', color: 0xffaa00, texture: createTexture('flower') },
        { id: 'saturn', name: 'Saturn Rings', color: 0xaa00ff, texture: createTexture('saturn') }
    ];

    let geometry = new THREE.BufferGeometry();
    let positions = [];
    let velocities = [];
    let colors = [];
    
    // Initialize Particles
    const colorObj = new THREE.Color();
    for (let i = 0; i < PARTICLE_COUNT; i++) {
        positions.push((Math.random() - 0.5) * 100); // x
        positions.push((Math.random() - 0.5) * 100); // y
        positions.push((Math.random() - 0.5) * 50);  // z
        
        velocities.push((Math.random() - 0.5) * 0.2); // vx
        velocities.push((Math.random() - 0.5) * 0.2); // vy
        velocities.push((Math.random() - 0.5) * 0.2); // vz

        // Initial Color
        colors.push(1, 1, 1);
    }

    geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

    let material = new THREE.PointsMaterial({
        size: 1.5,
        map: shapes[0].texture,
        transparent: true,
        opacity: 0.8,
        vertexColors: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false
    });

    const particles = new THREE.Points(geometry, material);
    scene.add(particles);

    // --- Main Animation Loop ---
    function animate() {
        requestAnimationFrame(animate);
        time += 0.01;

        // 1. Get Geometry Attributes
        const posAttr = geometry.attributes.position;
        const colAttr = geometry.attributes.color;

        // 2. Determine Target & Interaction
        // Mirror hand x for intuitive control
        const targetX = -handPosition.x * 40; 
        const targetY = -handPosition.y * 30; // Invert Y because MediaPipe is top-down 0-1
        const targetZ = 0;

        // Pinch logic: High pinch (small val) = Concentrate; Low pinch (high val) = Explode
        // Normalize pinch: 0.0 (touching) to ~0.5 (open)
        let expansionFactor = 0.5 + (pinchDistance * 4.0); // 0.5 tight, 3.0+ exploded
        if (!isHandPresent) expansionFactor = 0.5; // Idle state

        // 3. Update Particles
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            let px = posAttr.getX(i);
            let py = posAttr.getY(i);
            let pz = posAttr.getZ(i);

            // Physics: Attraction to hand
            const dx = targetX - px;
            const dy = targetY - py;
            const dz = targetZ - pz;

            // Simple eased movement towards target
            // Add some noise based on index to create "cloud" effect
            const noise = Math.sin(time + i) * expansionFactor;
            
            if (isHandPresent) {
                // Move towards hand
                px += dx * 0.05 + Math.cos(time * 2 + i) * 0.1 * expansionFactor;
                py += dy * 0.05 + Math.sin(time * 2 + i) * 0.1 * expansionFactor;
                pz += dz * 0.05;
                
                // Add "orbit" effect
                px += Math.sin(time * 2 + i * 0.1) * (expansionFactor * 0.2);
                py += Math.cos(time * 2 + i * 0.1) * (expansionFactor * 0.2);
            } else {
                // Idle floating
                px += Math.sin(time + i) * 0.05;
                py += Math.cos(time + i * 0.5) * 0.05;
            }

            posAttr.setXYZ(i, px, py, pz);
        }

        posAttr.needsUpdate = true;

        // 4. Shape Switching Logic (Timer Based)
        const shapeIndex = Math.floor((Date.now() / SHAPE_CYCLE_DURATION) % shapes.length);
        if (shapeIndex !== currentShapeIndex) {
            currentShapeIndex = shapeIndex;
            const shapeData = shapes[currentShapeIndex];
            
            // Update Material
            material.map = shapeData.texture;
            material.size = (shapeData.id === 'firework') ? 1.5 : 2.5;
            
            // Update UI
            document.getElementById('shape-name').innerText = shapeData.name;

            // Update Colors
            const targetColor = new THREE.Color(shapeData.color);
            for(let i=0; i<PARTICLE_COUNT; i++) {
                // Vary color slightly per particle
                const variation = (Math.random() - 0.5) * 0.2;
                colAttr.setXYZ(i, targetColor.r + variation, targetColor.g + variation, targetColor.b + variation);
            }
            colAttr.needsUpdate = true;
        }

        // Rotate entire system slightly
        particles.rotation.y += 0.002;

        renderer.render(scene, camera);
    }

    // --- MediaPipe Hands Integration ---
    const videoElement = document.querySelector('.input_video');
    
    function onResults(results) {
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            isHandPresent = true;
            const landmarks = results.multiHandLandmarks[0];

            // 1. Calculate Hand Position (Center of Palm approx)
            // Use index 9 (Middle finger knuckle) for stability
            const x = landmarks[9].x - 0.5; 
            const y = landmarks[9].y - 0.5;
            handPosition.set(x, y, 0);

            // 2. Calculate Pinch (Distance between Index tip [8] and Thumb tip [4])
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            const dx = thumbTip.x - indexTip.x;
            const dy = thumbTip.y - indexTip.y;
            pinchDistance = Math.sqrt(dx*dx + dy*dy); // Distance ~0 to 0.5

        } else {
            isHandPresent = false;
        }
    }

    const hands = new Hands({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }});

    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });

    hands.onResults(onResults);

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => {
            await hands.send({image: videoElement});
        },
        width: 640,
        height: 480
    });

    cameraUtils.start();

    // Start Animation
    animate();

    // Handle Resize
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

</script>
</body>
</html>
